using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Kompeldev.Generator.Deconstruct;

/// <summary>
///     Source generator that generates a deconstructor method for classes marked with the DeconstructorAttribute.
/// </summary>
[Generator]
public class DeconstructorGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider.ForAttributeWithMetadataName(
                "Kompeldev.Generator.Deconstruct.DeconstructAttribute",
                static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax,
                static (generatorSyntaxContext, _) => GetSemanticTarget(generatorSyntaxContext))
            .Where(target => target is not null);

        context.RegisterSourceOutput(classes,
            static (sourceProductionContext, classInfo) => Execute(classInfo, sourceProductionContext));

        context.RegisterPostInitializationOutput(static ctx => PostInitialize(ctx));
    }

    /// <summary>
    ///     Transforms the class information into a source file that contains a deconstructor method.
    /// </summary>
    /// <param name="classInfo"><see cref="ClassInfo" /> instance which contains class information.</param>
    /// <param name="sourceProductionContext">Context for registering new source file(s).</param>
    private static void Execute(ClassInfo? classInfo, SourceProductionContext sourceProductionContext)
    {
        if (classInfo is null) return;
        var (accessibility, namespaceName, className, properties) = classInfo;
        var builder = new StringBuilder();
        builder.Append($$"""
                         // <auto-generated/>
                         #nullable enable

                         namespace {{namespaceName}};

                         {{accessibility}} partial class {{className}}
                         {
                             public void Deconstruct(
                         """);
        for (var i = 0; i < properties.Count; i++)
        {
            var (name, type) = properties[i];
            builder.Append($"out {type} {name.ToLowerInvariant()}");
            if (i < properties.Count - 1) builder.Append(", ");
        }

        builder.Append($$"""
                         ) =>
                                 ({{string.Join(", ", properties.Select(x => x.Name.ToLowerInvariant()))}}) = ({{string.Join(", ", properties.Select(x => x.Name))}});
                         }
                         """);
        sourceProductionContext.AddSource($"{namespaceName}.{className}.Deconstructor.g.cs", builder.ToString());
    }

    /// <summary>
    ///     Callback invoked post-initialization. Registers the DeconstructAttribute source file.
    /// </summary>
    /// <param name="context">Context for registering new source file(s) post-initialization.</param>
    private static void PostInitialize(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource("Kompeldev.Generator.Deconstruct.DeconstructorAttribute.g.cs",
            SourceText.From(DeconstructConstants.DeconstructAttributeContent, Encoding.UTF8));
        context.AddSource("Kompeldev.Generator.Deconstruct.IgnorePropertyAttribute.g.cs",
            SourceText.From(DeconstructConstants.IgnorePropertyAttributeContent, Encoding.UTF8));
    }

    /// <summary>
    ///     Transforms the syntax node into a <see cref="ClassInfo" /> instance if it is a valid target for the generator.
    /// </summary>
    /// <param name="context">The context which contains Compilation etc.</param>
    /// <returns><see cref="ClassInfo" /> instance if required data is present; otherwise <c>null</c>.</returns>
    private static ClassInfo? GetSemanticTarget(GeneratorAttributeSyntaxContext context)
    {
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;
        var enumSymbol = context.SemanticModel.Compilation.GetTypeByMetadataName(
            "Kompeldev.Generator.Deconstruct.IgnorePropertyAttribute");
        var accessibility = classSymbol.DeclaredAccessibility.ToString().ToLower();
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString(
            SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle
                .Omitted));
        var className = classSymbol.Name;
        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(prop => prop is
            {
                DeclaredAccessibility: Accessibility.Public,
                Kind: SymbolKind.Property,
                IsStatic: false,
                GetMethod: not null
            })
            .Where(prop =>
                prop.GetAttributes()
                    .All(attr => !SymbolEqualityComparer.Default.Equals(attr.AttributeClass, enumSymbol)))
            .Select(prop => (prop.Name, prop.Type.ToDisplayString()))
            .ToArray();
        return properties.Length is 0
            ? null
            : new ClassInfo(accessibility, namespaceName, className,
                new EquatableArray<(string Name, string Type)>(properties));
    }
}