using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Kompeldev.Generator.Deconstruct;

/// <summary>
///     Source generator that generates a deconstructor method for classes marked with the DeconstructorAttribute.
/// </summary>
[Generator]
public class DeconstructorGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider.CreateSyntaxProvider(
                static (syntaxNode, _) => IsSyntaxTarget(syntaxNode),
                static (generatorSyntaxContext, _) => GetSemanticTarget(generatorSyntaxContext))
            .Where(target => target is not null);

        context.RegisterSourceOutput(classes,
            static (sourceProductionContext, classInfo) => Execute(classInfo, sourceProductionContext));

        context.RegisterPostInitializationOutput(static ctx => PostInitialize(ctx));
    }

    /// <summary>
    ///     Transforms the class information into a source file that contains a deconstructor method.
    /// </summary>
    /// <param name="classInfo"><see cref="ClassInfo" /> instance which contains class information.</param>
    /// <param name="sourceProductionContext">Context for registering new source file(s).</param>
    private static void Execute(ClassInfo? classInfo, SourceProductionContext sourceProductionContext)
    {
        if (classInfo is null) return;
        var (namespaceName, className, properties) = classInfo;
        var builder = new StringBuilder();
        builder.Append($$"""
                         // <auto-generated/>

                         namespace {{namespaceName}};

                         public partial class {{className}}
                         {
                             public void Deconstruct(
                         """);
        for (var i = 0; i < properties.Length; i++)
        {
            var (name, type) = properties[i];
            builder.Append($"out {type} {name}");
            if (i < properties.Length - 1) builder.Append(", ");
        }

        builder.Append("""
                       )
                           {

                       """);
        foreach (var (name, _) in properties)
            builder.AppendLine($"\t\t{name} = this.{name};");
        builder.Append("""
                           }
                       }
                       """);
        sourceProductionContext.AddSource($"{namespaceName}.{className}.Deconstructor.g.cs", builder.ToString());
    }

    /// <summary>
    ///     Callback invoked post-initialization. Registers the DeconstructAttribute source file.
    /// </summary>
    /// <param name="context">Context for registering new source file(s) post-initialization.</param>
    private static void PostInitialize(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource("Kompeldev.Generator.Deconstruct.DeconstructorAttribute.g.cs",
            SourceText.From(DeconstructConstants.AttributeContent, Encoding.UTF8));
    }

    /// <summary>
    ///     Helper method to determine if the syntax node is a target for the generator.
    /// </summary>
    /// <param name="node">The current SyntaxNode being parsed.</param>
    /// <returns><c>true</c> if the current node is considered a target; otherwise <c>false</c>.</returns>
    private static bool IsSyntaxTarget(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    /// <summary>
    ///     Transforms the syntax node into a <see cref="ClassInfo" /> instance if it is a valid target for the generator.
    /// </summary>
    /// <param name="context">The context which contains Compilation etc.</param>
    /// <returns><see cref="ClassInfo" /> instance if required data is present; otherwise <c>null</c>.</returns>
    private static ClassInfo? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        var attributeSymbol =
            context.SemanticModel.Compilation.GetTypeByMetadataName(
                "Kompeldev.Generator.Deconstruct.DeconstructAttribute");
        if (classSymbol is null || attributeSymbol is null) return null;
        var hasAttribute = classSymbol.GetAttributes()
            .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attributeSymbol));
        if (!hasAttribute) return null;
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(prop => prop is
            {
                DeclaredAccessibility: Accessibility.Public,
                Kind: SymbolKind.Property,
                IsStatic: false,
                GetMethod: not null
            })
            .Select(prop => (prop.Name, prop.Type.ToDisplayString()))
            .ToArray();
        return properties.Length is 0
            ? null
            : new ClassInfo(namespaceName, className, properties);
    }
}